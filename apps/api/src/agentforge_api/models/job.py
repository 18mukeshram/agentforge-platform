# apps/api/src/agentforge_api/models/job.py

"""Job models for execution queue."""

from datetime import datetime
from enum import Enum
from typing import Any, NewType

from pydantic import BaseModel, Field


JobId = NewType("JobId", str)


class JobStatus(str, Enum):
    """Status of a job in the queue."""
    
    PENDING = "pending"      # Created, waiting to be picked up
    RUNNING = "running"      # Currently being processed by worker
    COMPLETED = "completed"  # Finished successfully
    FAILED = "failed"        # Failed after all retries
    CANCELLED = "cancelled"  # Cancelled by user


class JobPriority(int, Enum):
    """Job priority levels."""
    
    LOW = 0
    NORMAL = 1
    HIGH = 2


class NodeJob(BaseModel):
    """
    A job representing a single node execution.
    
    This is what gets enqueued to BullMQ (or in-memory queue).
    Contains all information needed to execute the node independently.
    """
    
    id: str = Field(..., description="Unique job identifier")
    
    # Execution context
    execution_id: str
    workflow_id: str
    node_id: str
    
    # Node configuration snapshot
    node_type: str
    agent_id: str | None = None
    node_config: dict[str, Any] = Field(default_factory=dict)
    
    # Input data (resolved from parent outputs)
    inputs: dict[str, Any] = Field(default_factory=dict)
    
    # Job metadata
    status: JobStatus = JobStatus.PENDING
    priority: JobPriority = JobPriority.NORMAL
    
    # Retry configuration
    max_retries: int = 3
    retry_count: int = 0
    retry_backoff_ms: int = 1000
    
    # Timing
    created_at: datetime
    started_at: datetime | None = None
    completed_at: datetime | None = None
    
    # Result (populated after completion)
    output: Any | None = None
    error: str | None = None
    
    @property
    def job_id(self) -> JobId:
        """Return typed JobId."""
        return JobId(self.id)
    
    @property
    def can_retry(self) -> bool:
        """Check if job can be retried."""
        return self.retry_count < self.max_retries


class JobResult(BaseModel, frozen=True):
    """Result of job execution."""
    
    job_id: str
    node_id: str
    execution_id: str
    success: bool
    output: Any | None = None
    error: str | None = None
    duration_ms: int = 0


class ExecutionPlan(BaseModel):
    """
    Execution plan for a workflow.
    
    Generated by the orchestrator before execution starts.
    Contains topological order and dependency information.
    """
    
    execution_id: str
    workflow_id: str
    
    # Nodes in execution order (topological sort)
    execution_order: list[str]
    
    # Dependency map: node_id -> list of parent node_ids
    dependencies: dict[str, list[str]] = Field(default_factory=dict)
    
    # Reverse dependency map: node_id -> list of child node_ids
    dependents: dict[str, list[str]] = Field(default_factory=dict)
    
    # Entry nodes (no dependencies)
    entry_nodes: list[str] = Field(default_factory=list)
    
    # Exit nodes (no dependents)
    exit_nodes: list[str] = Field(default_factory=list)